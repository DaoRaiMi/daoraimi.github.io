# <center>Redis事务
## 事物命令
* multi
  > 在Redis中开启一个事务。这个命令总是返回OK。此后用户可以执行多个命令，但是Redis服务器并不会真正执行这些命令，而是将他们放到一个队列中，一旦EXEC命令执行了，那么Redis服务器就会执行队列中的命令。
* discard
  > 可以理解成取消事务。执行discard后，Redis会把缓存事务命令的队列给清空，最后退出事务。
* exec
  > 可以理解成提交事务，让Redis服务器执行事务中的命令。它会返回两个元素：
  > 1. **OK** 码
  > 2. **ERR** 回应

MULTI, EXEC, DISCARD和WATCH是Redis事务的基础，它们为事务中的一组命令的一步执行提供了两点保证：
1. 事务中的所有命令都会被序列化，并且会按顺序执行。在一个事务执行的过程中，绝不会发生另一个请求的执行。这就保证了所有被执行的命令都在一个单独的隔离的操作。
2. 对于事务中的命令要么都被执行，要么都不执行，所以说Redis的事务也是原子操作。EXEC命令会触发事务中的命令的执行。所以如果在执行EXEC命令之前，客户端到Redis的连接断开了，那么这个事务中的命令都不会被执行，反之如果执行了EXEC命令，则事务中的所有命令都会被执行。

## 事务中的错误
在一个Redis事务中，可能出现以下两种错误：
* 在将事务命令放入队列时出错，也就是在执行EXEC之前出的错。比如：命令的参数不对；
* 在执行了EXEC命令后，真正执行事务命令时，某个或某几个事务命令的执行报错。比如：使用GET命令去操作一个list的key；

客户端通过queued命令的返回值可以感知第一种错误的情况，如果返回的是**QUEUED**则表示命令被成功地放入的队列中，反之Redis会返回一个错误。如果在把命令放入队列时出现了错误，大多数的客户端会取消(discard)当前事务。

然而，从redis 2.6.5版本开始，redis会记录在累积命令时出现的错误，并且在用户执行了EXEC命令时会拒绝执行事务中的命令，然后也会返回一个错误, 最后自动地discard当前的事务。

在redis 2.6.5版本以前，当用户执行了EXEC命令后，redis会执行那些成功放入队列中的命令，并且忽略掉在累积命令时出现的错误。2.6.5版本之后的这个新特性，让事务和pipelining混合使用更加的简洁，使得事务中的命令能够一次性发送，并且在稍后来一次性读取所有的响应。

在事务执行中发生的错误并没有进行特殊的处理，也就是在执行EXEC后出现的错误，所有的命令都会被执行，即使其中有些命令执行会报错。

## 为什么Redis不支持rollback
如果有关系型数据库的使用经验，那么redis事务中出现了执行报错的命令，但是redis仍然执行了其他所有的命令，而不是执行回滚操作的事实，可能对你来说有点奇怪。

然而，对于这种行为有以下两种观点：
1. Redis命令只有在语法错误，或者操作一个错误类型的key时才会出错，也就是说这种错误是在编码原因导致的，应该能够在研发、测试的时候检测出来，并不会出现在生产环境。
2. Redis的内部实现非常简单和快捷，因为它不需要rollback的能力。

## 使用CAS(Check-And-Set)实现乐观锁
WATCH命令被用来在Redis事务中实现CAS操作，也就是乐观锁。使用WATCH来监控某些KEY的变更，如果在EXEC前至少有一个KEY被监控到有更改过，那么Redis事务就会被取消，并且EXEC命令也会返回一个NULL REPLY来表示Redis事务的失败。

也就是说，如果在WATCH后，EXEC之前，被监控的KEY发生的变更，那么当前的事务就会被取消。

WATCH命令让EXEC具有条件功能了，即：只有被WATCH监控的KEY都没有发生变更时，才执行Redis事务。
```
127.0.0.1:6379> set a 1
OK
127.0.0.1:6379> watch a
OK
127.0.0.1:6379> // 在另一个客户端中 set a 10
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a 2
QUEUED
127.0.0.1:6379> exec
(nil)  // 返回的NULL REPLY
127.0.0.1:6379> get a
"10" // a的值仍然是10
127.0.0.1:6379>
```
KEY被更改过的情形：

* 人为更改
* key 过期(expire)。在redis 6.0.9之前的版本，事务中相关key过期了，并不会导致事务被取消。
* key被eviction策略给删除了。

当EXEC执行后，所有被监控的KEY都会取取消监控(UNWATCH)，不管事务是否取消，当连接断开时，所有被监控的KEY也会被取消监控。
